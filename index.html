<!-- Curved Falling Lines – FINAL (no jump, top→bottom, center converge, +70% fan-out)
Checklist enforced:
- Hướng: TRÊN → DƯỚI (dashoffset luôn GIẢM)
- Chuyển động LIỀN MẠCH, không “teleport” giữa chừng
- Khoảng cách line ĐỀU, gồm 14 line (12 + 2 bên)
- Điểm chụm: CENTER, cách mép dưới 70px
- Độ mở (fan-out): +70% so với mặc định (trải rộng đều)
- Màu theo palette, chiều dài vệt 50–150px
- Resize: chỉ đặt “yêu cầu rebuild”; CHỈ rebuild line đó khi nó đã đi qua đáy (kết thúc vòng)
-->
<!doctype html><html lang="vi"><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Curved Falling Lines – stable</title>
<style>
  html,body{height:100%;margin:0;background:#0E1011;overflow:hidden}
  /* Không đặt/đổi viewBox động để tránh giật; vẽ theo toạ độ pixel thực */
  svg{position:fixed;inset:0;width:100%;height:100%;display:block}
  .track{fill:none;stroke:rgba(255,255,255,.08);stroke-width:1}
  .runner{fill:none;stroke-width:1;stroke-linecap:round}
</style>
</head><body>
<svg id="stage"></svg>
<script>
/* ===== CONFIG ===== */
const PALETTE     = ["#FFC413","#00A652","#FFBCFC","#4A4A48","#00A652","#C4C8FF"];
const LINE_COUNT  = 14;       // 12 + 2 line mép
const OPEN_FACTOR = 1.70;     // +70% fan-out
const FOCUS_OFF   = 70;       // chụm cách đáy 70px (px thực)
const SEG_MIN     = 50, SEG_MAX = 150;  // chiều dài vệt (px)
const DURATION    = 7;        // giây / vòng
const RESIZE_EPS  = 10;       // chỉ coi resize khi đổi >10px
/* =================== */

const svg = document.getElementById('stage');
const lerp = (a,b,t)=>a+(b-a)*t;
const pick = a => a[(Math.random()*a.length)|0];

/* State của từng line: rebuild độc lập, không reset giữa chừng */
let runners = []; // { g, track, el, color, len, seg, start, end, progress, index, pendingGeom|null }

/* ---- Geometry helpers ---- */
function positions(w){
  // Trải đều trên khoảng mở rộng +70% quanh tâm
  const L = w*0.5 - (w*0.5*OPEN_FACTOR);
  const R = w*0.5 + (w*0.5*OPEN_FACTOR);
  return Array.from({length:LINE_COUNT},(_,i)=> lerp(L, R, i/(LINE_COUNT-1)));
}
function pathD(x0, w, h){
  const cx = w*0.5, cy = h - FOCUS_OFF;   // CHỤM CENTER, cách đáy 70px
  const c1x = x0,    c1y = h * 0.35;
  const c2x = x0 + (cx - x0) * 0.90;      // uốn mạnh để fan-out rộng
  const c2y = h * (0.78 - 0.15*(OPEN_FACTOR-1));
  return `M ${x0},0 C ${c1x},${c1y} ${c2x},${c2y} ${cx},${cy}`;
}

/* ---- Khởi tạo lần đầu ---- */
function buildInitial(){
  svg.innerHTML = '';
  const w = svg.clientWidth, h = svg.clientHeight;
  const xs = positions(w);

  runners = xs.map((x, index)=>{
    const d = pathD(x, w, h);

    const g = document.createElementNS('http://www.w3.org/2000/svg','g');

    const track = document.createElementNS('http://www.w3.org/2000/svg','path');
    track.setAttribute('class','track');
    track.setAttribute('d', d);
    g.appendChild(track);

    const el = document.createElementNS('http://www.w3.org/2000/svg','path');
    const color = pick(PALETTE);
    el.setAttribute('class','runner');
    el.setAttribute('d', d);
    el.setAttribute('stroke', color);
    g.appendChild(el);

    svg.appendChild(g);

    const len = el.getTotalLength();                  // chiều dài path (px)
    const seg = Math.round(lerp(SEG_MIN, SEG_MAX, Math.random()));
    el.style.strokeDasharray = `${seg} ${len}`;

    // TOP → BOTTOM: dashoffset GIẢM từ (len+seg) tới (-seg)
    const start = len + seg, end = -seg;

    return {
      g, track, el, color,
      len, seg, start, end,
      progress: Math.random(), // lệch pha ban đầu để không đồng bộ
      index,
      pendingGeom: null
    };
  });
}

/* ---- Rebuild 1 line (độc lập), CHỈ sau khi line đó đi qua đáy ---- */
function rebuildOne(r, targetW, targetH){
  const xs = positions(targetW);
  const d  = pathD(xs[r.index], targetW, targetH);

  // cập nhật path ngay trong nhóm <g> của line đó (các line khác không bị ảnh hưởng)
  r.track.setAttribute('d', d);
  r.el.setAttribute('d', d);

  // tính lại length & dash trên path mới
  r.len = r.el.getTotalLength();
  r.start = r.len + r.seg;
  r.end   = -r.seg;
  r.el.style.strokeDasharray = `${r.seg} ${r.len}`;

  // reset về TRÊN CÙNG cho vòng kế: không hiện teleport vì đã qua đáy
  r.el.style.strokeDashoffset = `${r.start}px`;
  r.progress = 0;
  r.pendingGeom = null;
}

/* ---- Animation loop (rAF) – không CSS keyframes ---- */
let last = performance.now();
function tick(now){
  const dt = Math.min(50, now - last) / 1000; last = now;

  for (const r of runners){
    // Kiểm tra wrap sắp xảy ra (đi qua đáy) để rebuild nếu có pending
    const nextProgress = r.progress + dt / DURATION;
    if (r.pendingGeom && nextProgress >= 1){
      rebuildOne(r, r.pendingGeom.w, r.pendingGeom.h);
    }

    // Cập nhật tiến độ & offset (luôn GIẢM → TRÊN xuống DƯỚI)
    r.progress = (r.progress + dt / DURATION) % 1;
    const off = r.start + (r.end - r.start) * r.progress; // giảm dần
    r.el.style.strokeDashoffset = `${off}px`;
  }
  requestAnimationFrame(tick);
}

/* ---- Resize handling: chỉ đặt "yêu cầu rebuild" cho từng line ---- */
let lastW = svg.clientWidth, lastH = svg.clientHeight;
const ro = new ResizeObserver(entries=>{
  const {width, height} = entries[0].contentRect;
  if (Math.abs(width - lastW) > RESIZE_EPS || Math.abs(height - lastH) > RESIZE_EPS){
    lastW = width; lastH = height;
    // KHÔNG đổi viewBox, KHÔNG rebuild ngay → tránh giật
    // Đặt pendingGeom cho từng line; sẽ rebuild riêng line đó khi nó đi qua đáy
    for (const r of runners){
      r.pendingGeom = { w: width, h: height };
    }
  }
});

/* ---- Start ---- */
buildInitial();
ro.observe(svg);
requestAnimationFrame(tick);
</script>
</body></html>
