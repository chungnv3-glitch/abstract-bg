<!doctype html><html lang="vi"><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Curved Falling Lines – Canvas (instant responsive, no jump)</title>
<style>
  html,body{height:100%;margin:0;background:#0E1011;overflow:hidden}
  canvas{position:fixed;inset:0;width:100%;height:100%;display:block}
</style>
</head><body>
<canvas id="cv"></canvas>
<script>
/* ===== CONFIG (theo checklist) ===== */
const PALETTE=["#FFC413","#00A652","#FFBCFC","#4A4A48","#00A652","#C4C8FF"];
const LINE_COUNT=14;            // 12 + 2 bên, spacing đều
const OPEN_FACTOR=1.70;         // fan-out +70%
const FOCUS_OFF=70;             // chụm cách đáy 70px
const SEG_MIN=50, SEG_MAX=150;  // chiều dài vệt (px)
const DURATION=7;               // giây / vòng (trên→dưới)
const TRACK_ALPHA=0.08;         // track nền mờ
const SAMPLES=320;              // độ mịn nội suy cung
/* ============================= */

const cv=document.getElementById('cv');
const ctx=cv.getContext('2d');
let DPR=1, W=0, H=0;

const lerp=(a,b,t)=>a+(b-a)*t;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const pick=a=>a[(Math.random()*a.length)|0];

function setSize(){
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  W = Math.floor(innerWidth);
  H = Math.floor(innerHeight);
  cv.width  = Math.floor(W*DPR);
  cv.height = Math.floor(H*DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}

/* ---- Bézier cong & tra cứu chiều dài cung ---- */
function makeCurve(x0, w=W, h=H){
  const cx=w*0.5, cy=h-FOCUS_OFF;
  const p0={x:x0,y:0};
  const p1={x:x0,y:h*0.35};
  const p2={x:x0+(cx-x0)*0.90,y:h*(0.78-0.15*(OPEN_FACTOR-1))};
  const p3={x:cx,y:cy};
  const B=t=>{
    const u=1-t, uu=u*u, tt=t*t;
    return {
      x: uu*u*p0.x + 3*uu*t*p1.x + 3*u*tt*p2.x + tt*t*p3.x,
      y: uu*u*p0.y + 3*uu*t*p1.y + 3*u*tt*p2.y + tt*t*p3.y
    };
  };
  const pts=new Array(SAMPLES+1), lens=new Array(SAMPLES+1);
  let L=0;
  for(let i=0;i<=SAMPLES;i++){
    const t=i/SAMPLES, pt=B(t); pts[i]=pt;
    if(i===0) lens[i]=0; else { const dx=pt.x-pts[i-1].x, dy=pt.y-pts[i-1].y; L+=Math.hypot(dx,dy); lens[i]=L; }
  }
  const total=L;
  function tAtLen(s){
    s=clamp(s,0,total);
    let lo=0,hi=SAMPLES;
    while(lo<hi){ const mid=(lo+hi)>>1; (lens[mid]<s)?(lo=mid+1):(hi=mid); }
    const i=Math.max(1,lo), l0=lens[i-1], l1=lens[i], span=l1-l0||1, tt=(s-l0)/span;
    const t0=(i-1)/SAMPLES, t1=i/SAMPLES; return t0+(t1-t0)*tt;
  }
  return {pts,lens,total,B,tAtLen};
}

/* ---- Vẽ ---- */
function drawTrack(curve){
  ctx.globalAlpha=TRACK_ALPHA;
  ctx.beginPath();
  ctx.moveTo(curve.pts[0].x, curve.pts[0].y);
  for(let i=1;i<curve.pts.length;i++) ctx.lineTo(curve.pts[i].x, curve.pts[i].y);
  ctx.strokeStyle="white"; ctx.lineWidth=1; ctx.stroke();
  ctx.globalAlpha=1;
}
function drawSegment(curve, s0, s1, color){
  const a=clamp(s0,0,curve.total), b=clamp(s1,0,curve.total);
  if(b<=a) return;
  const t0=curve.tAtLen(a), t1=curve.tAtLen(b);
  const steps=Math.max(2, Math.round((t1-t0)*SAMPLES));
  ctx.beginPath();
  let t=t0, pt=curve.B(t); ctx.moveTo(pt.x,pt.y);
  for(let k=1;k<=steps;k++){ t=t0+(t1-t0)*(k/steps); pt=curve.B(t); ctx.lineTo(pt.x,pt.y); }
  ctx.strokeStyle=color; ctx.lineWidth=1; ctx.lineCap="round"; ctx.stroke();
}

/* ---- State ---- */
let lines=[];     // curves
let runners=[];   // {idx,color,seg,head,speedPxPerSec}

/* X theo fan-out đều */
function xPositions(){
  const L=W*0.5-(W*0.5*OPEN_FACTOR), R=W*0.5+(W*0.5*OPEN_FACTOR);
  return Array.from({length:LINE_COUNT},(_,i)=>lerp(L,R,i/(LINE_COUNT-1)));
}

function buildInitial(){
  lines.length=0; runners.length=0;
  const xs=xPositions();
  for(let i=0;i<LINE_COUNT;i++){
    const curve=makeCurve(xs[i],W,H);
    lines.push(curve);
    const seg=Math.round(lerp(SEG_MIN,SEG_MAX,Math.random()));
    const travel=curve.total+seg;
    const speed=travel/DURATION;
    runners.push({
      idx:i, color:pick(PALETTE), seg,
      head: Math.random()*travel,  // lệch pha ban đầu
      speedPxPerSec:speed
    });
  }
}

/* ---- Rebuild NGAY khi resize, nhưng GIỮ progress cho từng line ---- */
function rebuildPreserveProgress(){
  // Lưu progress hiện tại (0..1) của từng line
  const prog = runners.map(r=>{
    const curve=lines[r.idx]; const travel=curve.total + r.seg;
    return (travel>0)? (r.head % travel)/travel : 0;
  });

  // Cập nhật kích thước, geometry mới
  setSize();
  const xs = xPositions();
  lines = xs.map(x=> makeCurve(x, W, H));

  // Gán lại head/speed theo progress đã lưu → không teleport, căn giữa NGAY
  for(let i=0;i<LINE_COUNT;i++){
    const r = runners[i];
    r.idx = i;
    const travelNew = lines[i].total + r.seg;
    r.speedPxPerSec = travelNew / DURATION;
    r.head = prog[i] * travelNew;  // tiếp tục tại đúng vị trí tương ứng
  }
}

/* ---- Listeners cho responsive ngay lập tức ---- */
let rzTO=null, lastW=innerWidth, lastH=innerHeight, lastDPR=window.devicePixelRatio||1;
function scheduleImmediateRebuild(){
  clearTimeout(rzTO);
  rzTO = setTimeout(()=>{
    const curDPR = window.devicePixelRatio||1;
    if (Math.abs(innerWidth-lastW)>1 || Math.abs(innerHeight-lastH)>1 || Math.abs(curDPR-lastDPR)>1e-3){
      lastW=innerWidth; lastH=innerHeight; lastDPR=curDPR;
      rebuildPreserveProgress();  // căn giữa & update ngay
    }
  }, 80);
}
window.addEventListener('resize', scheduleImmediateRebuild, {passive:true});
window.addEventListener('orientationchange', scheduleImmediateRebuild, {passive:true});
matchMedia(`(resolution: ${window.devicePixelRatio||1}dppx)`).addEventListener?.('change', scheduleImmediateRebuild);
new ResizeObserver(()=>scheduleImmediateRebuild()).observe(cv);

/* ---- Animation loop ---- */
let lastTS=performance.now();
function frame(ts){
  const dt=Math.min(50, ts-lastTS)/1000; lastTS=ts;
  ctx.clearRect(0,0,W,H);

  // track
  for(const ln of lines) drawTrack(ln);

  // runners: TOP→BOTTOM (head tăng dần), wrap mượt
  for(const r of runners){
    const curve=lines[r.idx];
    const travel=curve.total + r.seg;
    r.head += r.speedPxPerSec * dt;
    const tail = r.head - r.seg;
    drawSegment(curve, tail, r.head, r.color);
    if(r.head >= travel) r.head -= travel;
  }

  requestAnimationFrame(frame);
}

/* ---- Start ---- */
(function start(){
  setSize();
  buildInitial();
  requestAnimationFrame(frame);
})();
</script>
</body></html>
