<!-- Curved Falling Lines – fixed:
1) Lines move TOP → BOTTOM (JS rAF, no CSS loop glitches)
2) Movement is continuous to the end point (no pause/jump)
3) Even spacing incl. 2 extra side lines (total = 14)
4) Wider fan-out (+30%), converge point is centered and 70px above bottom
-->
<!doctype html><html lang="vi"><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Curved Falling Lines</title>
<style>
  html,body{height:100%;margin:0;background:#0E1011;overflow:hidden}
  svg{position:fixed;inset:0;width:100%;height:100%;display:block}
  .track{fill:none;stroke:rgba(255,255,255,.08);stroke-width:1}
  .runner{fill:none;stroke-width:1;stroke-linecap:round}
</style>
</head><body>
<svg id="stage" preserveAspectRatio="none"></svg>
<script>
/* ===== Params ===== */
const COLORS   = ["#FFC413","#00A652","#FFBCFC","#4A4A48","#00A652","#C4C8FF"];
const LINE_CNT = 14;          // 12 + 2 bên
const DUR_S    = 7;           // thời gian rơi 1 vòng (giây)
const LEN_MIN  = 50, LEN_MAX = 150; // chiều dài vệt rơi
const OPEN     = 1.3;         // mở rộng 30%
const FOCUS_OFF= 70;          // điểm chụm cách đáy 70px

const svg = document.getElementById('stage');
const pick = a => a[(Math.random()*a.length)|0];
const lerp = (a,b,t)=>a+(b-a)*t;

let runners = []; // {path, seg, len, t, dur, startOff, endOff}

/* Bézier cong chụm về tâm (bottom-70) */
function pathD(x0,w,h){
  const cx=w*0.5, cy=h-FOCUS_OFF;
  const c1x=x0,  c1y=h*0.35;
  const c2x=x0 + (cx-x0)*0.9;                 // hơi kéo về tâm (mịn hơn)
  const c2y=h*(0.78-0.15*(OPEN-1));           // uốn tăng 30%
  return `M ${x0},0 C ${c1x},${c1y} ${c2x},${c2y} ${cx},${cy}`;
}

function build(){
  svg.innerHTML='';
  runners.length = 0;

  const w=svg.clientWidth, h=svg.clientHeight;
  svg.setAttribute('viewBox',`0 0 ${w} ${h}`);

  // khoảng x được mở rộng 30% nhưng vẫn chia đều
  const left  = w*0.5 - (w*0.5*OPEN);
  const right = w*0.5 + (w*0.5*OPEN);
  const xs = Array.from({length:LINE_CNT},(_,i)=> lerp(left,right, i/(LINE_CNT-1)));

  xs.forEach(x=>{
    const d = pathD(x,w,h);

    // track mờ
    const tr = document.createElementNS('http://www.w3.org/2000/svg','path');
    tr.setAttribute('class','track'); tr.setAttribute('d', d); svg.appendChild(tr);

    // runner màu
    const r  = document.createElementNS('http://www.w3.org/2000/svg','path');
    r.setAttribute('class','runner'); r.setAttribute('d', d);
    r.setAttribute('stroke', pick(COLORS));
    svg.appendChild(r);

    const pathLen = r.getTotalLength();
    const segLen  = Math.round(lerp(LEN_MIN, LEN_MAX, Math.random()));
    r.style.strokeDasharray = `${segLen} ${pathLen}`;

    // TOP → BOTTOM (liền mạch): offset đi từ -seg -> pathLen+seg, rồi loop
    runners.push({
      el: r,
      seg: segLen,
      len: pathLen,
      t: Math.random()*DUR_S,   // lệch pha ban đầu
      dur: DUR_S,
      startOff: -segLen,
      endOff: pathLen + segLen
    });
  });
}

/* render loop: không dùng CSS loop để tránh "giật & teleport" */
let last = performance.now();
function tick(nowMS){
  const dt = Math.min(50, nowMS-last)/1000; last = nowMS;

  for(const r of runners){
    r.t += dt;
    if (r.t > r.dur) r.t -= r.dur;                // loop liên tục
    const off = lerp(r.startOff, r.endOff, r.t/r.dur);
    r.el.style.strokeDashoffset = `${off}px`;
  }
  requestAnimationFrame(tick);
}

build();
requestAnimationFrame(tick);

// debounce resize để không rebuild liên tục (tránh cảm giác “nhảy vị trí”)
let rzTO;
addEventListener('resize', ()=>{
  clearTimeout(rzTO);
  rzTO = setTimeout(()=>{ build(); }, 120);
},{passive:true});
</script>
</body></html>
