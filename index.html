<!doctype html><html lang="vi"><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Curved Falling Lines – Canvas (stable, no jump)</title>
<style>
  html,body{height:100%;margin:0;background:#0E1011;overflow:hidden}
  canvas{position:fixed;inset:0;width:100%;height:100%;display:block}
</style>
</head><body>
<canvas id="cv"></canvas>
<script>
/* ================== CONFIG (theo checklist) ================== */
const PALETTE     = ["#FFC413","#00A652","#FFBCFC","#4A4A48","#00A652","#C4C8FF"];
const LINE_COUNT  = 14;      // 12 + 2 bên, spacing ĐỀU
const OPEN_FACTOR = 1.70;    // fan-out +70%
const FOCUS_OFF   = 70;      // điểm chụm = center, cách đáy 70px
const SEG_MIN     = 50, SEG_MAX = 150; // chiều dài vệt (px)
const DURATION    = 7;       // giây / vòng (TRÊN → DƯỚI)
const TRACK_ALPHA = 0.08;    // độ mờ track nền
const SAMPLES     = 320;     // độ mịn tính độ dài cung (arc length)
/* ============================================================= */

const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');

let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
let W=0, H=0;

const lerp = (a,b,t)=>a+(b-a)*t;
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const pick = a => a[(Math.random()*a.length)|0];

function setSize(){
  W = Math.floor(innerWidth);
  H = Math.floor(innerHeight);
  cv.width  = Math.floor(W * DPR);
  cv.height = Math.floor(H * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}

/* ---- Geometry for one curved line ---- */
function makeCurve(x0, w=W, h=H){
  const cx = w*0.5, cy = h - FOCUS_OFF;               // điểm chụm center, bottom-70
  const p0 = {x:x0, y:0};
  const p1 = {x:x0, y:h*0.35};
  const p2 = {x:x0 + (cx-x0)*0.90, y:h*(0.78 - 0.15*(OPEN_FACTOR-1))};
  const p3 = {x:cx, y:cy};

  const B = t=>{
    const u=1-t; const uu=u*u, tt=t*t;
    return {
      x: uu*u*p0.x + 3*uu*t*p1.x + 3*u*tt*p2.x + tt*t*p3.x,
      y: uu*u*p0.y + 3*uu*t*p1.y + 3*u*tt*p2.y + tt*t*p3.y
    };
  };

  // sample to get arc-length lookup
  const pts = new Array(SAMPLES+1);
  const lens = new Array(SAMPLES+1);
  let L = 0;
  for(let i=0;i<=SAMPLES;i++){
    const t = i/SAMPLES;
    const pt = B(t);
    pts[i]=pt;
    if(i===0){ lens[i]=0; }
    else{
      const dx=pt.x-pts[i-1].x, dy=pt.y-pts[i-1].y;
      L += Math.hypot(dx,dy);
      lens[i]=L;
    }
  }
  const total = L;

  // map arc length (px) → t via binary search
  function tAtLen(s){
    s = clamp(s, 0, total);
    let lo=0, hi=SAMPLES;
    while(lo<hi){
      const mid=(lo+hi)>>1;
      if(lens[mid] < s) lo=mid+1; else hi=mid;
    }
    const i = Math.max(1, lo);
    const l0=lens[i-1], l1=lens[i], span=l1-l0 || 1;
    const tt = (s - l0)/span;
    const t0=(i-1)/SAMPLES, t1=i/SAMPLES;
    return t0 + (t1-t0)*tt;
  }

  return { p0,p1,p2,p3, pts,lens,total, B, tAtLen };
}

/* ---- Lines (tracks) & runners state ---- */
let lines = [];   // fixed curves
let runners = []; // each: {idx, color, seg, dur, head, //arc head position in px
               // curveRef: lines[idx], pendingCurve (for resize), speedPxPerSec }

function buildInitial(){
  lines.length = 0; runners.length = 0;

  // even-spaced start X across fan-out (+70%)
  const left  = W*0.5 - (W*0.5*OPEN_FACTOR);
  const right = W*0.5 + (W*0.5*OPEN_FACTOR);
  const xs = Array.from({length:LINE_COUNT},(_,i)=> lerp(left, right, i/(LINE_COUNT-1)));

  for(let i=0;i<LINE_COUNT;i++){
    const curve = makeCurve(xs[i], W, H);
    lines.push(curve);

    const seg = Math.round(lerp(SEG_MIN, SEG_MAX, Math.random()));
    const color = pick(PALETTE);
    // tốc độ: để head đi từ -seg → total+seg trong DURATION giây
    const pathTravel = curve.total + seg;           // px
    const speed = pathTravel / DURATION;            // px / sec
    const headStart = Math.random() * pathTravel;   // lệch pha ban đầu
    runners.push({
      idx:i, color, seg,
      dur:DURATION,
      head: headStart,              // vị trí "đầu" vệt theo arc-length (0..pathTravel)
      speedPxPerSec: speed,
      pendingCurve: null            // khi resize: curve mới chờ áp dụng
    });
  }
}

/* ---- Draw helpers ---- */
function drawTrack(curve){
  ctx.globalAlpha = TRACK_ALPHA;
  ctx.beginPath();
  const pts = curve.pts;
  ctx.moveTo(pts[0].x, pts[0].y);
  for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.strokeStyle = "white";
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.globalAlpha = 1;
}

function drawSegment(curve, startLen, endLen, color){
  // clamp inside [0,total]
  const s0 = clamp(startLen, 0, curve.total);
  const s1 = clamp(endLen,   0, curve.total);
  if (s1 <= 0 || s0 >= curve.total || s1 <= s0) return;

  const t0 = curve.tAtLen(s0);
  const t1 = curve.tAtLen(s1);
  const steps = Math.max(2, Math.round((t1 - t0) * SAMPLES));

  ctx.beginPath();
  let t = t0;
  let pt = curve.B(t);
  ctx.moveTo(pt.x, pt.y);
  for(let k=1;k<=steps;k++){
    t = t0 + (t1 - t0) * (k/steps);
    pt = curve.B(t);
    ctx.lineTo(pt.x, pt.y);
  }
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.lineCap = "round";
  ctx.stroke();
}

/* ---- Animation loop (TOP → BOTTOM, liền mạch, không teleport) ---- */
let lastTS = performance.now();
function frame(ts){
  const dt = Math.min(50, ts - lastTS) / 1000; lastTS = ts;

  // clear
  ctx.clearRect(0,0,W,H);

  // draw tracks
  for(const ln of lines) drawTrack(ln);

  // runners
  for(const r of runners){
    const curve = lines[r.idx];
    const travel = curve.total + r.seg;       // head từ 0..total+seg
    // update head (TOP→BOTTOM ⇒ tăng dần)
    r.head += r.speedPxPerSec * dt;

    // nếu có pending curve & "đuôi" đã qua đáy → rebuild line này NGAY LÚC wrap
    const tail = r.head - r.seg;
    if (r.pendingCurve && tail >= travel){
      // áp dụng curve mới, giữ continuity: bắt đầu vòng mới từ trên
      lines[r.idx] = r.pendingCurve;
      r.pendingCurve = null;
      // tính lại speed theo geometry mới
      const travelNew = lines[r.idx].total + r.seg;
      r.speedPxPerSec = travelNew / r.dur;
      r.head = 0; // bắt đầu lại từ trên cùng
    }

    // vẽ đoạn [tail, head] giao với [0,total]
    drawSegment(curve, tail, r.head, r.color);

    // nếu head vượt qua (total+seg) → reset cho vòng kế
    if (r.head >= travel){
      r.head -= travel; // wrap mượt (xuất hiện lại từ trên)
    }
  }

  requestAnimationFrame(frame);
}

/* ---- Resize: ĐỘC LẬP từng line, CHỈ rebuild khi runner qua đáy ---- */
let lastW = 0, lastH = 0;
const ro = new ResizeObserver(entries=>{
  const {width, height} = entries[0].contentRect;
  const dW = Math.abs(width - lastW), dH = Math.abs(height - lastH);
  if (dW<8 && dH<8) return; // debounce layout rung nhẹ
  lastW = width; lastH = height;

  // cập nhật canvas ngay (độ phân giải), NHƯNG geometry sẽ thay từng line khi đến chu kỳ của nó
  setSize();

  // chuẩn bị curve mới cho từng line, nhưng CHƯA áp dụng
  const left  = W*0.5 - (W*0.5*OPEN_FACTOR);
  const right = W*0.5 + (W*0.5*OPEN_FACTOR);
  const xs = Array.from({length:LINE_COUNT},(_,i)=> lerp(left, right, i/(LINE_COUNT-1)));

  for(let i=0;i<LINE_COUNT;i++){
    const newCurve = makeCurve(xs[i], W, H);
    runners[i].pendingCurve = newCurve; // áp dụng khi "đuôi" qua đáy (tail >= travel)
  }
});

function start(){
  setSize();
  buildInitial();
  ro.observe(cv);
  requestAnimationFrame(frame);
}
start();
</script>
</body></html>
