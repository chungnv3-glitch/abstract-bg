<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Grid Flicker</title>
  <style>
    html, body { height:100%; margin:0; background:#0E1011; overflow:hidden; }
    canvas { width:100%; height:100%; display:block; }
  </style>
</head>
<body>
<canvas id="bg"></canvas>

<script>
/* === CONFIG === */
const DOT = 24;                  // kích thước ô vuông
const CELL = DOT * 1.5;          // khoảng cách = 50% DOT
const GRID_COLOR = "#C4C4C4";    
const GRID_ALPHA = 0.05;         // opacity 5%
const DOT_R = 2;                 // bo góc

const COLORS = ["#FFC413","#00A652","#FFBCFC","#4A4A48","#00A652","#C4C8FF"];
const COLORED_COUNT = 10;        // số ô màu cùng lúc

const T_FADE = 1.0;              // fade 1s
const T_HOLD = 0.3;              // giữ 0.3s
const CYCLE = 2*(T_FADE+T_HOLD); // chu kỳ đầy đủ

/* === Canvas setup === */
const cvs = document.getElementById("bg");
const ctx = cvs.getContext("2d");
let cols, rows, ox, oy, w, h;

function resize() {
  w = cvs.width = window.innerWidth;
  h = cvs.height = window.innerHeight;
  cols = Math.floor(w / CELL);
  rows = Math.floor(h / CELL);
  ox = (w - cols*CELL) / 2;
  oy = (h - rows*CELL) / 2;
  rebuildActive();
}
window.addEventListener("resize", resize);
resize();

function rrect(x,y,w,h,r) {
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

/* === Active cells logic === */
let active = [], used = new Set();
function key(i,j){return i+","+j;}

function randomCell() {
  let i = (Math.random()*cols)|0;
  let j = (Math.random()*rows)|0;
  return {i,j,k:key(i,j)};
}

function spawnOne() {
  let {i,j,k} = randomCell();
  while (used.has(k)) { let tmp = randomCell(); i=tmp.i;j=tmp.j;k=tmp.k; }
  used.add(k);
  return {i,j,k,color:COLORS[Math.random()*COLORS.length|0],t:Math.random()*CYCLE};
}

function rebuildActive() {
  active=[]; used.clear();
  for (let n=0;n<Math.min(COLORED_COUNT, cols*rows);n++) active.push(spawnOne());
}

/* === Animation helpers === */
function ease(t){return t<0?0:t>1?1:t*t*(3-2*t);}
function phaseAlpha(t){
  if(t<T_FADE) return ease(t/T_FADE);
  if(t<T_FADE+T_HOLD) return 1;
  if(t<T_FADE+T_HOLD+T_FADE) return 1-ease((t-T_FADE-T_HOLD)/T_FADE);
  return 0;
}

/* === Draw === */
let last = performance.now();
function frame(nowMs){
  const dt=(nowMs-last)/1000; last=nowMs;

  ctx.fillStyle="#0E1011";
  ctx.fillRect(0,0,w,h);

  // draw grid
  ctx.globalAlpha=GRID_ALPHA;
  ctx.fillStyle=GRID_COLOR;
  for(let j=0;j<rows;j++){
    for(let i=0;i<cols;i++){
      const x=ox+i*CELL-DOT/2, y=oy+j*CELL-DOT/2;
      rrect(x,y,DOT,DOT,DOT_R);
      ctx.fill();
    }
  }
  ctx.globalAlpha=1;

  // draw actives
  for (let c of active){
    c.t=(c.t+dt)%CYCLE;
    const alpha=phaseAlpha(c.t);

    // nếu hết chu kỳ -> chuyển chỗ
    if(c.t<dt){
      used.delete(c.k);
      let {i,j,k}=randomCell();
      while(used.has(k)) { let tmp=randomCell(); i=tmp.i;j=tmp.j;k=tmp.k; }
      used.add(k);
      c.i=i;c.j=j;c.k=k;
      c.color=COLORS[Math.random()*COLORS.length|0];
    }

    ctx.globalAlpha=alpha;
    ctx.fillStyle=c.color;
    const x=ox+c.i*CELL-DOT/2, y=oy+c.j*CELL-DOT/2;
    rrect(x,y,DOT,DOT,DOT_R);
    ctx.fill();
  }
  ctx.globalAlpha=1;

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
