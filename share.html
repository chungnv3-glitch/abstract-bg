<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Grid – Flicker Colors</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0E1011; }
    canvas { position: fixed; inset: 0; width: 100%; height: 100%; display: block; }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>

  <script>
    /* ========= CONFIG ========= */
    const DOT = 24;                 // kích thước ô vuông (px)
    const CELL = DOT * 1.5;         // khoảng cách giữa các tâm = 50% kích thước ô
    const DOT_R = 2;                // bo góc
    const EDGE_MARGIN = 5;          // chừa mép 5px

    // Lưới ô ghi – KHÔNG nhấp nháy
    const GRID_COLOR = "#C4C4C4";
    const GRID_ALPHA = 0.05;        // = 5%

    // Ô màu nhấp nháy tại chỗ
    const COLORED_COUNT = 30;       // tăng lên 30 ô màu
    const PALETTE = ["#FFC413","#00A652","#FFBCFC","#4A4A48","#00A652","#C4C8FF"];

    // Chu kỳ chuyển màu: ghi -> màu -> ghi
    const T_FADE = 1.0;             // thời gian fade (giây)
    const T_HOLD = 3.5;             // GIỮ 3.5s (trước là 1.5s)
    const CYCLE = 2 * (T_FADE + T_HOLD);

    /* ========= Canvas & Grid ========= */
    const cvs = document.getElementById('bg');
    const ctx = cvs.getContext('2d', { alpha: false });
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    let cols=0, rows=0, ox=EDGE_MARGIN, oy=EDGE_MARGIN;

    function resize(){
      cvs.width  = Math.floor(innerWidth  * DPR);
      cvs.height = Math.floor(innerHeight * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);

      cols = Math.max(1, Math.floor((innerWidth  - EDGE_MARGIN*2 - DOT) / CELL) + 1);
      rows = Math.max(1, Math.floor((innerHeight - EDGE_MARGIN*2 - DOT) / CELL) + 1);

      ox = EDGE_MARGIN;
      oy = EDGE_MARGIN;
    }
    addEventListener('resize', resize, { passive:true }); resize();

    function rrect(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    /* ========= Pick static colored cells ========= */
    function pickCells(){
      const picked = new Set(), list = [];
      const want = Math.min(COLORED_COUNT, cols*rows);
      const key = (i,j)=> i + "," + j;
      while (list.length < want){
        const i = (Math.random()*cols)|0;
        const j = (Math.random()*rows)|0;
        const k = key(i,j);
        if (!picked.has(k)){
          picked.add(k);
          list.push({
            i, j,
            color: PALETTE[(Math.random()*PALETTE.length)|0],
            offset: Math.random() * CYCLE,
            lastSeg: -1
          });
        }
      }
      return list;
    }
    let colored = pickCells();

    /* ========= Helpers ========= */
    const ease = t => t<0 ? 0 : t>1 ? 1 : (t*t*(3-2*t));
    function phaseAlpha(t){
      if (t < T_FADE) return ease(t / T_FADE);
      if (t < T_FADE + T_HOLD) return 1;
      if (t < T_FADE + T_HOLD + T_FADE) return 1 - ease((t - T_FADE - T_HOLD) / T_FADE);
      return 0;
    }
    function segIndex(t){
      if (t < T_FADE) return 0;
      if (t < T_FADE + T_HOLD) return 1;
      if (t < T_FADE + T_HOLD + T_FADE) return 2;
      return 3;
    }

    /* ========= Render Loop ========= */
    function drawGrid(){
      ctx.globalAlpha = GRID_ALPHA;
      ctx.fillStyle = GRID_COLOR;
      for (let j=0;j<rows;j++){
        for (let i=0;i<cols;i++){
          const x = ox + i*CELL;
          const y = oy + j*CELL;
          rrect(x,y,DOT,DOT,DOT_R);
          ctx.fill();
        }
      }
      ctx.globalAlpha = 1;
    }

    function frame(nowMs){
      const now = nowMs/1000;

      ctx.fillStyle = "#0E1011";
      ctx.fillRect(0,0,innerWidth,innerHeight);

      drawGrid();

      for (const c of colored){
        let t = (now + c.offset) % CYCLE;
        const seg = segIndex(t);
        if ((c.lastSeg !== seg) && seg === 0){
          c.color = PALETTE[(Math.random()*PALETTE.length)|0];
        }
        c.lastSeg = seg;

        const a = phaseAlpha(t);
        const x = ox + c.i*CELL;
        const y = oy + c.j*CELL;
        ctx.globalAlpha = a;
        ctx.fillStyle = c.color;
        rrect(x,y,DOT,DOT,DOT_R);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  </script>
</body>
</html>
