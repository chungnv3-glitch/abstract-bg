<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Grid – Flicker Colors</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0E1011; }
    canvas { position: fixed; inset: 0; width: 100%; height: 100%; display: block; }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>

  <script>
    /* ========= CONFIG ========= */
    const DOT = 24;                 // kích thước ô vuông (px)
    const CELL = DOT * 1.5;         // khoảng cách giữa các tâm = 50% kích thước ô
    const DOT_R = 2;                // bo góc
    const EDGE_MARGIN = 5;          // chừa mép 5px

    // Lưới ô ghi – KHÔNG nhấp nháy
    const GRID_COLOR = "#C4C4C4";
    const GRID_ALPHA = 0.05;        // = 5%

    // Ô màu nhấp nháy tại chỗ
    const COLORED_COUNT = 10;       // số ô màu (bạn chỉnh tùy ý)
    const PALETTE = ["#FFC413","#00A652","#FFBCFC","#4A4A48","#00A652","#C4C8FF"];

    // Chu kỳ chuyển màu: ghi -> màu -> ghi
    const T_FADE = 1.0;             // thời gian fade (giây)
    const T_HOLD = 0.3;             // giữ sau mỗi lần chuyển
    const CYCLE = 2 * (T_FADE + T_HOLD);

    /* ========= Canvas & Grid ========= */
    const cvs = document.getElementById('bg');
    const ctx = cvs.getContext('2d', { alpha: false });
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    let cols=0, rows=0, ox=0, oy=0;

    function resize(){
      cvs.width  = Math.floor(innerWidth  * DPR);
      cvs.height = Math.floor(innerHeight * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);

      cols = Math.floor((innerWidth  - EDGE_MARGIN*2) / CELL);
      rows = Math.floor((innerHeight - EDGE_MARGIN*2) / CELL);

      // căn giữa & chừa mép
      ox = Math.max(EDGE_MARGIN, Math.round((innerWidth  - cols*CELL)/2));
      oy = Math.max(EDGE_MARGIN, Math.round((innerHeight - rows*CELL)/2));
    }
    addEventListener('resize', resize, { passive:true }); resize();

    function rrect(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    /* ========= Pick static colored cells ========= */
    function pickCells(){
      const picked = new Set(), list = [];
      const want = Math.min(COLORED_COUNT, cols*rows);
      const key = (i,j)=> i + "," + j;
      while (list.length < want){
        const i = (Math.random()*cols)|0;
        const j = (Math.random()*rows)|0;
        const k = key(i,j);
        if (!picked.has(k)){
          picked.add(k);
          list.push({
            i, j,
            color: PALETTE[(Math.random()*PALETTE.length)|0],
            // lệch pha ban đầu để không đồng bộ
            offset: Math.random() * CYCLE,
            lastSeg: -1
