<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Grid – Rolling Flicker</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0E1011; }
    canvas { position: fixed; inset: 0; width: 100%; height: 100%; display: block; }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>

  <script>
    /* ========= CONFIG ========= */
    const DOT = 24;                 // kích thước ô vuông (px)
    const CELL = DOT * 1.5;         // khoảng cách = 50% kích thước ô
    const DOT_R = 2;                // bo góc
    const EDGE_MARGIN = 5;          // chừa mép 5px

    // Lưới ô ghi – KHÔNG nhấp nháy
    const GRID_COLOR = "#C4C4C4";
    const GRID_ALPHA = 0.05;        // = 5%

    // Ô màu (mật độ cố định), mỗi ô chạy chu kỳ rồi nhường cho ô khác
    const COLORED_COUNT = 10;       // GIỮ MẬT ĐỘ: luôn có đúng từng này ô đang hoạt động
    const PALETTE = ["#FFC413","#00A652","#FFBCFC","#4A4A48","#00A652","#C4C8FF"];

    // Chu kỳ: ghi -> (fade 1s) -> giữ 0.3s -> (fade 1s) -> giữ 0.3s
    const T_FADE = 1.0;             // thời gian fade (giây)
    const T_HOLD = 0.3;             // giữ sau mỗi lần chuyển
    const CYCLE = 2 * (T_FADE + T_HOLD);

    /* ========= Canvas & Grid ========= */
    const cvs = document.getElementById('bg');
    const ctx = cvs.getContext('2d', { alpha: false });
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    let cols=0, rows=0, ox=0, oy=0;

    function resize(){
      cvs.width  = Math.floor(innerWidth  * DPR);
      cvs.height = Math.floor(innerHeight * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);

      cols = Math.floor((innerWidth  - EDGE_MARGIN*2) / CELL);
      rows = Math.floor((innerHeight - EDGE_MARGIN*2) / CELL);

      // căn giữa & chừa mép
      ox = Math.max(EDGE_MARGIN, Math.round((innerWidth  - cols*CELL)/2));
      oy = Math.max(EDGE_MARGIN, Math.round((innerHeight - rows*CELL)/2));

      rebuildActive(); // khi thay đổi kích thước, chọn lại các ô hoạt động
    }
    addEventListener('resize', resize, { passive:true }); resize();

    function rrect(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    /* ========= Rolling selection ========= */
    // danh sách ô đang hoạt động (đúng COLORED_COUNT phần tử)
    let active = [];
    const used = new Set();              // set "i,j" các cell đang dùng để tránh trùng

    function key(i,j){ return i + "," + j; }

    function randomFreeCell(){
      // chọn một ô chưa được dùng
      for (let tries=0; tries<500; tries++){
        const i = (Math.random()*cols)|0;
        const j = (Math.random()*rows)|0;
        const k = key(i,j);
        if (!used.has(k)) return {i,j,k};
      }
      // fallback nếu lưới nhỏ: cho phép đè
      const i = (Math.random()*cols)|0;
      const j = (Math.random()*rows)|0;
      return {i,j,k:key(i,j)};
    }

    function spawnOne(){
      const {i,j,k} = randomFreeCell();
      used.add(k);
      return {
        i, j, k,
        color: PALETTE[(Math.random()*PALETTE.length)|0],
        t: Math.random()*CYCLE // lệch pha ban đầu để không đồng bộ
      };
    }

    function rebuildActive(){
      active = [];
      used.clear();
      const want = Math.min(COLORED_COUNT, cols*rows);
      for (let n=0; n<want; n++) active.push(spawnOne());
    }

    // ease mượt cho alpha
    const ease = t => t<0 ? 0 : t>1 ? 1 : (t*t*(3-2*t));
    function phaseAlpha(t){
      // t trong [0..CYCLE)
      if (t < T_FADE) return ease(t / T_FADE);                            // ghi -> màu
      if (t < T_FADE + T_HOLD) return 1;                                  // giữ màu
      if (t < T_FADE + T_HOLD + T_FADE) return 1 - ease((t - T_FADE - T_HOLD) / T_FADE); // màu -> ghi
      return 0;                                                           // giữ ghi
    }
    function segIndex(t){
      if (t < T_FADE) return 0;
      if (t < T_FADE + T_HOLD) return 1;
      if (t < T_FADE + T_HOLD + T_FADE) return 2;
      return 3;
    }

    /* ========= Render ========= */
    function drawGrid(){
      ctx.globalAlpha = GRID_ALPHA;
      ctx.fillStyle = GRID_COLOR;
      for (let j=0;j<rows;j++){
        for (let i=0;i<cols;i++){
          const x = ox + i*CELL - DOT/2;
          const y = oy + j*CELL - DOT/2;
          rrect(x,y,DOT,DOT,DOT_R);
          ctx.fill();
        }
      }
      ctx.globalAlpha = 1;
    }

    let last = performance.now();
    function frame(nowMs){
      const now = nowMs/1000;
      const dt  = Math.min(50, nowMs - last) / 1000; last = nowMs;

      // nền
      ctx.fillStyle = "#0E1011";
      ctx.fillRect(0,0,innerWidth,innerHeight);

      // lưới ghi
      drawGrid();

      // vẽ & cập nhật các ô đang hoạt động
      for (let idx=0; idx<active.length; idx++){
        const c = active[idx];
        const t = (c.t += dt) % CYCLE;

        // bắt đầu chu kỳ -> chọn màu mới (ghi -> màu)
        if (segIndex(t) === 0 && segIndex((t-dt+CYCLE)%CYCLE) !== 0){
          c.color = PALETTE[(Math.random()*PALETTE.length)|0];
        }

        // nếu vừa kết thúc cả chu kỳ (vào đoạn hold ghi) và đi qua ranh giới
        if (segIndex(t) === 3 && segIndex((t-dt+CYCLE)%CYCLE) !== 3){
          // giải phóng cell cũ
          used.delete(c.k);
          // chọn một cell ghi NGẪU NHIÊN mới để bắt đầu chu kỳ khác
          const {i,j,k} = randomFreeCell();
          used.add(k);
          c.i = i; c.j = j; c.k = k;
          // lệch pha để tạo lấp lánh
          c.t = Math.random()*CYCLE*0.25; // start gần đầu chu kỳ nhưng không đồng bộ
        }

        const alpha = phaseAlpha(t);
        const x = ox + c.i*CELL - DOT/2;
        const y = oy + c.j*CELL - DOT/2;

        ctx.globalAlpha = alpha;
        ctx.fillStyle = c.color;
        rrect(x,y,DOT,DOT,DOT_R);
        ctx.fill(); // không stroke, không glow
      }
      ctx.globalAlpha = 1;

      requestAnimationFrame(frame);
    }
    rebuildActive();
    requestAnimationFrame(frame);
  </script>
</body>
</html>
