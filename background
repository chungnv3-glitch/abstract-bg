<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Interactive Abstract Background</title>
    <style>
      html, body { height: 100%; margin: 0; background: #0f1220; overflow: hidden; }
      canvas { position: fixed; inset: 0; width: 100%; height: 100%; display: block; }
      .grain {
        position: fixed; inset: 0; pointer-events: none; mix-blend-mode: overlay; opacity: .06;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="180" height="180"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="2" stitchTiles="stitch"/><feColorMatrix type="saturate" values="0"/><feComponentTransfer><feFuncA type="table" tableValues="0 0.5" /></feComponentTransfer></filter><rect width="100%" height="100%" filter="url(%23n)"/></svg>');
        background-size: 180px 180px; animation: move 12s linear infinite alternate;
      }
      @keyframes move { from { transform: translate3d(-2%, -2%, 0); } to { transform: translate3d(2%, 2%, 0); } }
      @media (prefers-reduced-motion: reduce) { .grain { animation: none; } }
    </style>
  </head>
  <body>
    <canvas id="bg"></canvas>
    <div class="grain" aria-hidden="true"></div>

    <script>
      const PALETTE = ['#a78bfa','#93c5fd','#5eead4','#fde68a','#fca5a5'];
      const BLOBS = 7, BASE_RADIUS = 180, SPEED = 0.12, FLOAT_SPEED = 0.0015, MOUSE_INFLUENCE = 120;

      const canvas = document.getElementById('bg');
      const ctx = canvas.getContext('2d', { alpha: false });

      let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      let vw = 0, vh = 0;
      function resize() {
        vw = window.innerWidth; vh = window.innerHeight;
        canvas.width = Math.floor(vw * dpr); canvas.height = Math.floor(vh * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      window.addEventListener('resize', resize, { passive: true }); resize();

      const pointer = { x: vw/2, y: vh/2 }, target = { x: vw/2, y: vh/2 };
      function onMove(e){ const x = e.clientX ?? (e.touches && e.touches[0]?.clientX) ?? vw/2;
                          const y = e.clientY ?? (e.touches && e.touches[0]?.clientY) ?? vh/2;
                          target.x = x; target.y = y; }
      window.addEventListener('mousemove', onMove, { passive: true });
      window.addEventListener('touchmove', onMove, { passive: true });
      window.addEventListener('mouseleave', () => { target.x = vw/2; target.y = vh/2; }, { passive: true });

      window.addEventListener('deviceorientation', (e) => {
        if (e.beta == null || e.gamma == null) return;
        const nx = (e.gamma || 0) / 45, ny = (e.beta || 0) / 90;
        target.x = vw * (0.5 + nx * 0.25); target.y = vh * (0.5 + ny * 0.25);
      });

      const blobs = Array.from({ length: BLOBS }, (_, i) => ({
        hue: PALETTE[i % PALETTE.length],
        base: { x: vw * (0.25 + 0.5 * Math.random()), y: vh * (0.25 + 0.5 * Math.random()) },
        offset: { x: 0, y: 0 },
        r: BASE_RADIUS * (0.6 + Math.random() * 0.9),
        t: Math.random() * 1000,
        drift: (0.6 + Math.random() * 0.8)
      }));

      let last = performance.now();
      function frame(now) {
        const dt = Math.min(32, now - last); last = now;

        const dx = target.x - pointer.x, dy = target.y - pointer.y;
        pointer.x += dx * SPEED; pointer.y += dy * SPEED;

        ctx.fillStyle = '#0f1220'; ctx.fillRect(0, 0, vw, vh);

        for (const b of blobs) {
          b.t += dt * FLOAT_SPEED * b.drift;
          const fx = Math.cos(b.t * 1.7) * 40 * b.drift;
          const fy = Math.sin(b.t * 1.3) * 40 * b.drift;
          const nx = (pointer.x / vw - 0.5) * 2, ny = (pointer.y / vh - 0.5) * 2;
          b.offset.x = nx * MOUSE_INFLUENCE * b.drift + fx;
          b.offset.y = ny * MOUSE_INFLUENCE * b.drift + fy;

          const cx = b.base.x + b.offset.x, cy = b.base.y + b.offset.y;
          const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, b.r);
          grad.addColorStop(0, b.hue + 'cc'); grad.addColorStop(1, '#0f122000');
          ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx, cy, b.r, 0, Math.PI * 2); ctx.fill();
        }

        const g = ctx.createRadialGradient(vw*0.5, vh*0.55, Math.min(vw, vh)*0.2, vw*0.5, vh*0.55, Math.max(vw, vh)*0.8);
        g.addColorStop(0, 'rgba(0,0,0,0)'); g.addColorStop(1, 'rgba(0,0,0,0.35)');
        ctx.fillStyle = g; ctx.fillRect(0, 0, vw, vh);

        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);
    </script>
  </body>
</html>
